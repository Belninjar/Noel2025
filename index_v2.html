<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Craft QR</title>
  <style>
    :root {
      --w: 1365;
      --h: 2048;
      --font: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;

      /* Zones (en %) */
      --cam-left: 29.82%;
      --cam-top: 24.66%;
      --cam-width: 40.29%;
      --cam-height: 18.31%;

      --slot1-left: 13.76%;
      --slot1-top: 56.15%;
      --slot1-width: 17.3%;
      --slot1-height: 11.52%;

      --slot2-left: 69.33%;
      --slot2-top: 56.15%;
      --slot2-width: 17.3%;
      --slot2-height: 11.52%;

      --msg-left: 5.15%;
      --msg-top: 80.79%;
      --msg-width: 89.75%;
      --msg-height: 15.95%;
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: #0b0b0b;
      display: grid;
      place-items: center;
      font-family: var(--font);
      overscroll-behavior: none;
      touch-action: manipulation;
    }

    /* Plateau (image de fond) */
    #board {
      position: relative;
      width: min(100vw, calc(100vh * (var(--w) / var(--h))));
      aspect-ratio: var(--w) / var(--h);
      background: url("UI.png") center/contain no-repeat;
      user-select: none;
      -webkit-user-select: none;
    }

    /* Zone caméra */
    #camRegion {
      position: absolute;
      left: var(--cam-left);
      top: var(--cam-top);
      width: var(--cam-width);
      height: var(--cam-height);
      overflow: hidden;
      border-radius: 18px;
      background: #000;
    }

    #video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      transform: translateZ(0);
    }

    #camOverlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center; /* FIX: ancien "place-itemsContent" incorrect */
      padding: 12px;
      text-align: center;
      color: rgba(255,255,255,0.92);
      font-weight: 800;
      text-shadow: 0 2px 12px rgba(0,0,0,0.9);
      background: linear-gradient(to bottom, rgba(0,0,0,0.55), rgba(0,0,0,0.15));
      pointer-events: none;
      opacity: 1;
      transition: opacity .2s ease;
    }
    #camOverlay.hidden { opacity: 0; }

    #tinyControls {
      position: absolute;
      left: 10px;
      top: 10px;
      display: flex;
      gap: 8px;
      z-index: 3;
    }

    .tinyBtn {
      border: 0;
      border-radius: 12px;
      padding: 8px 10px;
      font-weight: 800;
      cursor: pointer;
      background: rgba(255,255,255,0.9);
      box-shadow: 0 6px 18px rgba(0,0,0,0.25);
    }
    .tinyBtn:active { transform: translateY(1px); }

    /* Slots cartes */
    .slot {
      position: absolute;
      overflow: hidden;
      border-radius: 10px;
    }
    #slot1 { left: var(--slot1-left); top: var(--slot1-top); width: var(--slot1-width); height: var(--slot1-height); }
    #slot2 { left: var(--slot2-left); top: var(--slot2-top); width: var(--slot2-width); height: var(--slot2-height); }

    .slot img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: none;
      cursor: pointer;
      filter: drop-shadow(0 10px 14px rgba(0,0,0,0.35));
      -webkit-tap-highlight-color: transparent;
    }

    /* ===== TEXTE: transparent + blanc + toujours dans le cadre ===== */
    #messageBox {
      position: absolute;
      left: var(--msg-left);
      top: var(--msg-top);
      width: var(--msg-width);
      height: var(--msg-height);
      padding: 10px 12px;

      background: transparent;
      border: none;
      box-shadow: none;

      color: #fff;
      font-weight: 900;
      line-height: 1.15;
      text-align: center;
      white-space: pre-line;
      overflow: hidden;

      font-size: clamp(14px, 2.2vw, 30px);
      text-shadow: 0 2px 10px rgba(0,0,0,0.9);

      display: flex;
      align-items: center;
      justify-content: center;
    }
    #messageBox.ok  { text-shadow: 0 2px 10px rgba(0,0,0,0.9), 0 0 14px rgba(60, 200, 120, 0.35); }
    #messageBox.bad { text-shadow: 0 2px 10px rgba(0,0,0,0.9), 0 0 14px rgba(240, 80, 80, 0.35); }

    /* Démarrage caméra via geste utilisateur */
    #startHitbox {
      position: absolute;
      inset: 0;
      cursor: pointer;
    }

    /* ===== Bouton SCAN discret en bas à droite ===== */
    #btnScan {
      position: absolute;
      right: 3.2%;
      bottom: 3.0%;
      width: min(70px, 10vw);
      aspect-ratio: 1 / 1;
      border-radius: 999px;
      border: 2px solid rgba(255, 215, 0, 0.75);
      background: rgba(0,0,0,0.28);
      color: rgba(255, 235, 160, 0.95);
      font-weight: 950;
      letter-spacing: 0.5px;
      font-size: clamp(10px, 1.3vw, 14px);
      box-shadow: 0 10px 18px rgba(0,0,0,0.35);
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      z-index: 7;
    }
    #btnScan:active { transform: translateY(1px); }
    #btnScan.active {
      background: rgba(255, 215, 0, 0.75);
      border-color: rgba(255, 255, 255, 0.9);
      color: rgba(30, 18, 0, 0.95);
      box-shadow: 0 0 0 3px rgba(255,215,0,0.22), 0 10px 18px rgba(0,0,0,0.35);
    }

    /* ===== Animation craft (halo + étincelles) ===== */
    #fxLayer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 6;
    }
    .fxItem {
      position: absolute;
      left: 50%;
      top: 46%;
      width: min(180px, 22vw);
      aspect-ratio: 1 / 1;
      transform: translate(-50%, -50%) scale(0.6);
      opacity: 0;
      filter: drop-shadow(0 18px 28px rgba(0,0,0,0.45));
      animation: fxPop 1700ms ease-out forwards;
    }
    .fxItem img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }
    .fxItem::before {
      content: "";
      position: absolute;
      inset: -18%;
      background: radial-gradient(circle at 50% 50%,
        rgba(255, 245, 190, 0.75) 0%,
        rgba(255, 215, 0, 0.35) 30%,
        rgba(255, 215, 0, 0.12) 55%,
        rgba(255, 215, 0, 0.00) 72%);
      filter: blur(2px);
      opacity: 0.0;
      animation: fxHalo 1700ms ease-out forwards;
      z-index: -1;
    }
    .fxItem::after {
      content: "";
      position: absolute;
      inset: -30%;
      background:
        radial-gradient(circle, rgba(255,255,255,0.95) 0 2px, rgba(255,255,255,0) 3px) 20% 25%/34px 34px,
        radial-gradient(circle, rgba(255,255,255,0.85) 0 1.5px, rgba(255,255,255,0) 3px) 65% 55%/28px 28px,
        radial-gradient(circle, rgba(255,255,255,0.80) 0 1.2px, rgba(255,255,255,0) 3px) 40% 75%/30px 30px;
      opacity: 0;
      animation: fxSpark 1700ms ease-out forwards;
      z-index: 1;
      pointer-events: none;
    }

    @keyframes fxPop {
      0%   { opacity: 0; transform: translate(calc(-50% + var(--dx, 0px)), -50%) scale(0.55); }
      18%  { opacity: 1; transform: translate(calc(-50% + var(--dx, 0px)), -50%) scale(1.04); }
      38%  { opacity: 1; transform: translate(calc(-50% + var(--dx, 0px)), -52%) scale(1.00); }
      100% { opacity: 0; transform: translate(calc(-50% + var(--dx, 0px)), -70%) scale(0.96); }
    }
    @keyframes fxHalo {
      0%   { opacity: 0.0; transform: scale(0.9); }
      18%  { opacity: 0.95; transform: scale(1.02); }
      55%  { opacity: 0.65; transform: scale(1.08); }
      100% { opacity: 0.0; transform: scale(1.15); }
    }
    @keyframes fxSpark {
      0%   { opacity: 0; transform: rotate(0deg); }
      20%  { opacity: 0.95; }
      55%  { opacity: 0.55; transform: rotate(18deg); }
      100% { opacity: 0; transform: rotate(32deg); }
    }
  </style>
</head>
<body>
  <div id="board">
    <div id="camRegion">
      <video id="video" playsinline muted></video>

      <div id="tinyControls">
        <button class="tinyBtn" id="btnStop" title="Arrêter la caméra" style="display:none;">⏹</button>
        <button class="tinyBtn" id="btnReset" title="Retirer les 2 cartes">↺</button>
      </div>

      <div id="camOverlay">
        Touchez ici pour activer la caméra<br/>
        puis maintenez SCAN pour lire une carte
      </div>

      <div id="startHitbox" aria-label="Démarrer la caméra"></div>
    </div>

    <div id="slot1" class="slot"><img id="img1" alt="Carte 1" /></div>
    <div id="slot2" class="slot"><img id="img2" alt="Carte 2" /></div>

    <div id="messageBox">Prêt. Active la caméra, puis maintiens SCAN.</div>

    <!-- Layer d'animation -->
    <div id="fxLayer" aria-hidden="true"></div>

    <!-- Bouton scan -->
    <button id="btnScan" aria-label="Scanner" title="Maintenir pour scanner">SCAN</button>
  </div>

  <!-- QR-SCANNER (UMD) + Worker -->
  <script src="https://unpkg.com/qr-scanner@1.4.2/qr-scanner.umd.min.js"></script>
  <script>
    QrScanner.WORKER_PATH = "https://unpkg.com/qr-scanner@1.4.2/qr-scanner-worker.min.js";
  </script>

  <script>
    /**
     * ===== CONFIG FICHIERS =====
     * UI.png à côté du fichier.
     * Images cartes (les QR scannés) :   /cards/0001.png etc.
     * Images objets craftés (outputs) :  /items/1001.png etc. (IDs définis dans RECIPES)
     */
    const CARD_IMAGE_BASE = "cards/";
    const ITEM_IMAGE_BASE = "cards/";
    const IMAGE_EXTS = ["png", "jpg", "jpeg", "webp"];

    /**
     * ===== RECETTES =====
     * Nouvelle logique:
     *   [keyOf("0002","0004")]: { outputs: ["1001"] }
     * Plusieurs objets craftés:
     *   { outputs: ["1002","1003"] }
     *
     * Optionnel: table ITEMS pour avoir des noms affichés.
     */
    const ITEMS = {
      "0001": { name: "Couteau" },
      "0002": { name: "Bois" },
      "0003": { name: "Feuilles" },
      "0004": { name: "Fil" },
      "0005": { name: "Hameçon" },
      "0006": { name: "Canne à pêche" },
      "0007": { name: "Corde" },
      "0008": { name: "Hache" },
      "0009": { name: "Étincelle" },
      "0010": { name: "Feu" },
      "0011": { name: "Cabane" },
      "0012": { name: "Cabane humide" },
      "0013": { name: "Début de canne à pêche" }
    };

    function keyOf(a, b) {
      const A = String(a).trim();
      const B = String(b).trim();
      return [A, B].sort().join("|");
    }

    const RECIPES = {
      [keyOf("0002","0004")]: { outputs: ["0001"] },              // Couteau
      [keyOf("0001","0005")]: { outputs: ["0004"] },              // Fil
      [keyOf("0004","0006")]: { outputs: ["0013"] },              // Début canne
      [keyOf("0003","0005")]: { outputs: ["0005"] },              // Hameçon
      [keyOf("0007","0008")]: { outputs: ["0006"] },              // Canne à pêche
      [keyOf("0005","0000")]: { outputs: ["0007"] },              // Corde
      [keyOf("0005","0018")]: { outputs: ["0008"] },              // Hache
      [keyOf("0011","0012")]: { outputs: ["0002","0003"] },       // Bois + Feuilles (exemple multi-output)
      [keyOf("0015","0016")]: { outputs: ["0011"] },              // Cabane
      [keyOf("0013","0018")]: { outputs: ["0012"] },              // Cabane humide
      [keyOf("0002","0002")]: { outputs: ["0009"] },              // Étincelle
      [keyOf("0019","0013")]: { outputs: ["0010"] },              // Feu
    };

    const els = {
      startHitbox: document.getElementById("startHitbox"),
      camOverlay: document.getElementById("camOverlay"),
      btnStop: document.getElementById("btnStop"),
      btnReset: document.getElementById("btnReset"),
      btnScan: document.getElementById("btnScan"),
      video: document.getElementById("video"),
      msg: document.getElementById("messageBox"),
      img1: document.getElementById("img1"),
      img2: document.getElementById("img2"),
      fxLayer: document.getElementById("fxLayer"),
    };

    let qrScanner = null;
    let slot1 = null;
    let slot2 = null;

    // Anti spam scan (évite déclenchement multiple)
    const COOLDOWN_MS = 800;
    const lastSeen = new Map();

    // 1x1 transparent (évite erreurs réseau quand on “vide” une image)
    const BLANK_IMG = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";

    // Scan uniquement pendant appui bouton
    let scanArmed = false;
    let scanConsumed = false;

    // Message hold (succès reste plus longtemps)
    const SUCCESS_HOLD_MS = 6000;
    let holdUntil = 0;

    function fitMessageText() {
      const el = els.msg;
      el.style.fontSize = "";
      const computed = getComputedStyle(el);
      let size = parseFloat(computed.fontSize) || 18;
      const min = 12;
      while (el.scrollHeight > el.clientHeight && size > min) {
        size -= 1;
        el.style.fontSize = size + "px";
      }
    }

    function setMessage(text, kind = "", opts = {}) {
      const now = Date.now();

      // Si un succès est en "hold", on ignore les messages non-forcés
      if (!opts.force && now < holdUntil) return;

      els.msg.textContent = text;
      els.msg.classList.remove("ok", "bad");
      if (kind) els.msg.classList.add(kind);

      if (typeof opts.holdMs === "number") {
        holdUntil = now + opts.holdMs;
      } else if (opts.force) {
        // une action utilisateur ou une erreur peut casser le hold
        holdUntil = 0;
      }

      requestAnimationFrame(fitMessageText);
    }

    function normalizeCode(raw) {
      const s = String(raw ?? "").trim();
      const m = s.match(/\b\d{4}\b/);
      return (m ? m[0] : s).trim();
    }

    function itemLabel(id) {
      const key = String(id);
      return ITEMS[key]?.name ? `${ITEMS[key].name} (${key})` : key;
    }

    function clearSlot(n) {
      const imgEl = (n === 1) ? els.img1 : els.img2;
      imgEl.onerror = null;
      imgEl.onload = null;

      if (n === 1) slot1 = null; else slot2 = null;

      imgEl.removeAttribute("data-code");
      imgEl.style.display = "none";
      imgEl.src = BLANK_IMG;

      // action utilisateur => force (et casse le hold succès)
      if (!slot1 && !slot2) {
        setMessage("Prêt. Maintiens SCAN pour lire une carte.", "", { force: true });
      } else if (slot1 && !slot2) {
        setMessage("Carte 1 en place.\nMaintiens SCAN pour lire la deuxième carte.", "", { force: true });
      } else if (!slot1 && slot2) {
        setMessage("Carte 2 en place.\nMaintiens SCAN pour lire la première carte.", "", { force: true });
      } else {
        evaluateCraft(true);
      }
    }

    function clearBoth() {
      clearSlot(1);
      clearSlot(2);
    }

    function setImageWithFallback(imgEl, bases, code) {
      imgEl.onerror = null;
      imgEl.onload = null;

      imgEl.style.display = "block";
      imgEl.setAttribute("data-code", code);

      let baseIdx = 0;
      let extIdx = 0;

      const tryNext = () => {
        if (imgEl.getAttribute("data-code") !== code) return;

        if (baseIdx >= bases.length) {
          // image absente => message d’erreur (force, car c’est une info utile)
          setMessage(`Image introuvable pour le code ${code}.`, "bad", { force: true });
          return;
        }

        const base = bases[baseIdx];
        if (extIdx >= IMAGE_EXTS.length) {
          baseIdx++;
          extIdx = 0;
          tryNext();
          return;
        }

        const ext = IMAGE_EXTS[extIdx++];
        imgEl.src = `${base}${code}.${ext}`;
      };

      imgEl.onerror = () => {
        if (imgEl.getAttribute("data-code") !== code) return;
        tryNext();
      };

      tryNext();
    }

    function setSlotCardImage(imgEl, code) {
      setImageWithFallback(imgEl, [CARD_IMAGE_BASE], code);
    }

    function placeCard(code) {
      if (slot1 && slot2) {
        setMessage("Deux cartes déjà en place.\nTouchez une carte pour la retirer et rescanner.", "bad", { force: true });
        return false;
      }

      if (!slot1) {
        slot1 = code;
        setSlotCardImage(els.img1, code);
        setMessage("Carte 1 enregistrée.\nMaintiens SCAN pour lire la deuxième carte.");
        return true;
      }

      if (!slot2) {
        slot2 = code;
        setSlotCardImage(els.img2, code);
        evaluateCraft(false);
        return true;
      }

      return false;
    }

    function playCraftAnimation(outputIds) {
      // Nettoie les FX précédents (évite accumulation)
      els.fxLayer.innerHTML = "";

      const ids = (outputIds || []).slice(0, 3); // limite visuelle
      const spacing = 140; // px (sera bien sur mobile car taille responsive)

      ids.forEach((id, i) => {
        const fx = document.createElement("div");
        fx.className = "fxItem";

        // décalage horizontal si plusieurs outputs
        const dx = (i - (ids.length - 1) / 2) * (ids.length === 1 ? 0 : spacing);
        fx.style.setProperty("--dx", `${dx}px`);

        const img = document.createElement("img");
        img.alt = `Objet ${id}`;

        // essaie items/ puis fallback sur cards/ si tu réutilises les mêmes images
        setImageWithFallback(img, [ITEM_IMAGE_BASE, CARD_IMAGE_BASE], String(id));

        fx.appendChild(img);
        els.fxLayer.appendChild(fx);

        // auto-remove après animation
        setTimeout(() => fx.remove(), 1900);
      });
    }

    function evaluateCraft(forceMessage) {
      if (!slot1 || !slot2) return;

      const k = keyOf(slot1, slot2);
      const recipe = RECIPES[k];

      if (!recipe || !Array.isArray(recipe.outputs) || recipe.outputs.length === 0) {
        if (navigator.vibrate) navigator.vibrate([40, 60, 40]);
        setMessage("Mauvaise association.\nTouchez une carte pour la retirer.", "bad", { force: true });
        return;
      }

      // Animation des objets craftés
      playCraftAnimation(recipe.outputs);

      // Message succès (reste plus longtemps)
      const outputsLines = recipe.outputs.length === 1
        ? [`Objet crafté : ${itemLabel(recipe.outputs[0])}`]
        : ["Objets craftés :", ...recipe.outputs.map(id => `• ${itemLabel(id)}`)];

      if (navigator.vibrate) navigator.vibrate(80);

      setMessage(
        outputsLines.join("\n"),
        "ok",
        { force: !!forceMessage || true, holdMs: SUCCESS_HOLD_MS } // force + hold
      );
    }

    function disarmScanUI() {
      scanArmed = false;
      scanConsumed = false;
      els.btnScan.classList.remove("active");
    }

    function onDetected(raw) {
      // Gating: ignore tant que SCAN n'est pas maintenu + 1 scan par appui
      if (!scanArmed || scanConsumed) return;

      const code = normalizeCode(raw);
      if (!code) return;

      const now = Date.now();
      const last = lastSeen.get(code) || 0;
      if (now - last < COOLDOWN_MS) return;
      lastSeen.set(code, now);

      const placed = placeCard(code);
      if (placed) {
        scanConsumed = true;
        scanArmed = false;
        els.btnScan.classList.remove("active");
      }
    }

    async function startScanner() {
      if (qrScanner) return;

      qrScanner = new QrScanner(
        els.video,
        (result) => onDetected(result?.data ?? result),
        {
          preferredCamera: "environment",
          returnDetailedScanResult: true,
          maxScansPerSecond: 12,
        }
      );

      try {
        await qrScanner.start();
        els.camOverlay.classList.add("hidden");
        els.btnStop.style.display = "inline-block";
        if (!slot1 && !slot2) setMessage("Caméra active.\nMaintiens SCAN pour lire une carte.", "", { force: true });
      } catch {
        qrScanner.destroy();
        qrScanner = null;
        setMessage("Impossible d’accéder à la caméra.\nOuvre la page en HTTPS (ou localhost) et accepte la permission.", "bad", { force: true });
      }
    }

    function stopScanner() {
      if (!qrScanner) return;
      qrScanner.stop();
      qrScanner.destroy();
      qrScanner = null;
      els.btnStop.style.display = "none";
      els.camOverlay.classList.remove("hidden");
      disarmScanUI();
      setMessage("Caméra arrêtée.\nTouchez l’écran caméra pour redémarrer.", "", { force: true });
    }

    // ===== Events =====
    els.startHitbox.addEventListener("click", startScanner);
    els.startHitbox.addEventListener("touchend", (e) => { e.preventDefault(); startScanner(); }, { passive: false });

    els.btnStop.addEventListener("click", stopScanner);
    els.btnReset.addEventListener("click", clearBoth);

    // Tap carte => suppression (force + casse le hold)
    els.img1.addEventListener("click", () => clearSlot(1));
    els.img2.addEventListener("click", () => clearSlot(2));
    els.img1.addEventListener("touchend", (e) => { e.preventDefault(); clearSlot(1); }, { passive: false });
    els.img2.addEventListener("touchend", (e) => { e.preventDefault(); clearSlot(2); }, { passive: false });

    // Bouton SCAN (maintenir)
    els.btnScan.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      if (!qrScanner) startScanner();
      scanArmed = true;
      scanConsumed = false;
      els.btnScan.classList.add("active");
      try { els.btnScan.setPointerCapture(e.pointerId); } catch {}
    }, { passive: false });

    const releaseScan = (e) => {
      e.preventDefault?.();
      disarmScanUI();
      try { if (e?.pointerId != null) els.btnScan.releasePointerCapture(e.pointerId); } catch {}
    };
    els.btnScan.addEventListener("pointerup", releaseScan, { passive: false });
    els.btnScan.addEventListener("pointercancel", releaseScan, { passive: false });
    els.btnScan.addEventListener("pointerleave", releaseScan, { passive: false });

    window.addEventListener("beforeunload", () => {
      if (qrScanner) {
        qrScanner.stop();
        qrScanner.destroy();
        qrScanner = null;
      }
    });

    // Init
    requestAnimationFrame(fitMessageText);
  </script>
</body>
</html>
